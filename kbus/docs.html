<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>KBUS -- Lightweight kernel-mediated messaging</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="kbus-lightweight-kernel-mediated-messaging">
<h1 class="title">KBUS -- Lightweight kernel-mediated messaging</h1>
<p>This is emergent documentation for the KBUS kernel module.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This documentation is kept as a reStructuredText document.
If you are looking at an HTML file, then it is provided for your
convenience, and may not be up-to-date.</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#intention" id="id3" name="id3">Intention</a></li>
<li><a class="reference" href="#the-basics" id="id4" name="id4">The basics</a><ul>
<li><a class="reference" href="#python" id="id5" name="id5">Python</a></li>
</ul>
</li>
<li><a class="reference" href="#messages" id="id6" name="id6">Messages</a><ul>
<li><a class="reference" href="#message-names" id="id7" name="id7">Message names</a></li>
<li><a class="reference" href="#message-ids" id="id8" name="id8">Message ids</a></li>
<li><a class="reference" href="#message-content" id="id9" name="id9">Message content</a><ul>
<li><a class="reference" href="#unset" id="id10" name="id10">Unset</a></li>
<li><a class="reference" href="#the-message-header" id="id11" name="id11">The message header</a></li>
<li><a class="reference" href="#the-message-body" id="id12" name="id12">The message body</a></li>
</ul>
</li>
<li><a class="reference" href="#message-flags" id="id13" name="id13">Message flags</a><ul>
<li><a class="reference" href="#send-flags" id="id14" name="id14">Send flags</a></li>
</ul>
</li>
<li><a class="reference" href="#things-kbus-changes-in-a-message" id="id15" name="id15">Things KBUS changes in a message</a></li>
</ul>
</li>
<li><a class="reference" href="#types-of-message" id="id16" name="id16">Types of message</a><ul>
<li><a class="reference" href="#announcements" id="id17" name="id17">Announcements</a></li>
<li><a class="reference" href="#request-message" id="id18" name="id18">Request message</a></li>
<li><a class="reference" href="#reply-message" id="id19" name="id19">Reply message</a></li>
<li><a class="reference" href="#status-message" id="id20" name="id20">Status message</a></li>
<li><a class="reference" href="#requests-and-replies" id="id21" name="id21">Requests and Replies</a></li>
</ul>
</li>
<li><a class="reference" href="#kbus-end-points-ksocks" id="id22" name="id22">KBUS end points - KSocks</a><ul>
<li><a class="reference" href="#the-kbus-devices" id="id23" name="id23">The KBUS devices</a></li>
<li><a class="reference" href="#ksocks" id="id24" name="id24">KSocks</a></li>
<li><a class="reference" href="#senders" id="id25" name="id25">Senders</a></li>
<li><a class="reference" href="#listeners" id="id26" name="id26">Listeners</a></li>
<li><a class="reference" href="#repliers" id="id27" name="id27">Repliers</a></li>
</ul>
</li>
<li><a class="reference" href="#more-information" id="id28" name="id28">More information</a><ul>
<li><a class="reference" href="#stateful-transactions" id="id29" name="id29">Stateful transactions</a></li>
<li><a class="reference" href="#queues-filling-up" id="id30" name="id30">Queues filling up</a></li>
<li><a class="reference" href="#urgent-messages" id="id31" name="id31">Urgent messages</a></li>
<li><a class="reference" href="#select-write-send-and-next-message-blocking" id="id32" name="id32">Select, write/send and &quot;next message&quot;, blocking</a></li>
<li><a class="reference" href="#ioctls" id="id33" name="id33">IOCTLS</a></li>
<li><a class="reference" href="#proc-kbus-bindings" id="id34" name="id34">/proc/kbus/bindings</a></li>
<li><a class="reference" href="#proc-kbus-stats" id="id35" name="id35">/proc/kbus/stats</a></li>
<li><a class="reference" href="#error-numbers" id="id36" name="id36">Error numbers</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="intention" name="intention">Intention</a></h1>
<p>KBUS provides lightweight kernel-mediated messaging for Linux.</p>
<ul class="simple">
<li>&quot;lightweight&quot; means that there is no intent to provide complex or
sophisticated mechanisms - if you need something more, consider DBUS or
other alternatives.</li>
<li>&quot;kernel-mediated&quot; means that the actual business of message passing and
message synchronisation is handled by a kernel module.</li>
<li>&quot;for Linux&quot; means what it says - the initial code is for the Linux kernel.</li>
</ul>
<p>Initial use is expected to be in embedded systems.</p>
<p>There is (at least initially) no intent to aim for a &quot;fast&quot; system - this is
not aimed at real-time systems.</p>
<p>Although the initial implementation is kernel-mediated, it is assumed that
there will eventually be bindings for message transmission over ethernet.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="the-basics" name="the-basics">The basics</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="python" name="python">Python</a></h2>
<p>Although the KBUS kernel module is written in C, the module tests are written
in Python, and there is a Python module providing useful interfaces, which is
expected to be the normal way of using KBUS (at least initially).</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id6" id="messages" name="messages">Messages</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="message-names" name="message-names">Message names</a></h2>
<p>All messages have names - for instance &quot;$.Sensors.Kitchen&quot;.</p>
<p>All message names start with &quot;$.&quot;, followed by one or more alphanumeric words
separated by dots. There are two wildcard characters, &quot;*&quot; and &quot;%&quot;, which can
be the last word of a name.</p>
<p>Thus (in some notation or other):</p>
<pre class="literal-block">
name := '$.'  [ word '.' ]+  ( word  | '*' | '%' )
word := alphanumerics
</pre>
<p>Case is significant. There is probably a limit on the maximum size of a
subname, and also on the maximum length of a message name.</p>
<p>Names form a name hierarchy or tree - so &quot;$.Sensors&quot; might have children
&quot;$.Sensors.Kitchen&quot; and &quot;$.Sensors.Bedroom&quot;.</p>
<p>If the last word of a name is &quot;*&quot;, then this is a wildcard name that also
includes all the child names at that level and below -- i.e., all the names
that start with the name up to the &quot;*&quot;. So &quot;$.Sensors.*&quot; includes
&quot;$.Sensors.Kitchen&quot;, &quot;$.Sensors.Bedroom&quot;, &quot;$.Sensors.Kitchen.FireAlarm&quot;,
&quot;$.Sensors.Kitchen.Toaster&quot;, &quot;$.Sensors.Bedroom.FireAlarm&quot;, and so on.</p>
<p>If the last word of a name is &quot;%&quot;, then this is a wildcard name that also
includes all the child names at that level -- i.e., all the names obtained by
replacing the &quot;%&quot; by another word. So &quot;$.Sensors.%&quot; includes
&quot;$.Sensors.Kitchen&quot; and &quot;$.Sensors.Bedroom&quot;, but not
&quot;$.Sensors.Kitchen.Toaster&quot;.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="message-ids" name="message-ids">Message ids</a></h2>
<p>Every message is expected to have a unique id.</p>
<p>A message id is made up of two parts, a network id and a serial number.</p>
<p>The network id is used to carry useful information when a message is
transferred from one KBUS system to another (for instance, over a bridge). By
default (for local messages) it is 0.</p>
<p>A serial number is used to identify the particular message within a network.</p>
<p>If a message is sent via KBUS with a network id of 0, then KBUS itself will
assign a new message id to the message, with the network id (still) 0, and
with the serial number one more than the last serial number assigned. Thus for
local messages, message ids ascend, and their order is deterministic.</p>
<p>If a message is sent via KBUS with a non-zero network id, then KBUS does not
touch its message id.</p>
<p>Network ids are represented textually as <tt class="docutils literal"><span class="pre">{n,s}</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> is the
network id and <tt class="docutils literal"><span class="pre">s</span></tt> is the serial number.</p>
<blockquote>
Message id {0,0} is reserved for use as an invalid message id. Both
network id and serial number are unsigned 323-bit integers. Note that this
means that local serial numbers will eventually wrap.</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="message-content" name="message-content">Message content</a></h2>
<p>Messages are made of the following parts:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">start and end guards:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">These are both unsigned 32-bit words. 'start_guard' is notionally &quot;kbus&quot;,
and 'end_guard' (the 32 bit word after the rest of the message) is
notionally &quot;subk&quot;. Obviously that depends on how one looks at the 32-bit
word. Every message shall start with a start guard and end with an end
guard.</p>
<p class="last">These provide some help in checking that a message is well formed, and in
particular the end guard helps to check for broken length fields.</p>
</td>
</tr>
</tbody>
</table>
<div class="section">
<h3><a class="toc-backref" href="#id10" id="unset" name="unset">Unset</a></h3>
<p>Unset values are 0, or have zero length (as appropriate).</p>
<p>It is not possible for a message name to be unset.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id11" id="the-message-header" name="the-message-header">The message header</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">message id:</th><td class="field-body"><p class="first">identifies this particular message. This is made up of a network
id and a serial number, and is discussed in <a class="reference" href="#message-ids">Message ids</a>.</p>
<p>When replying to a message, copy this value into the 'In reply to' field.</p>
</td>
</tr>
<tr class="field"><th class="field-name">in reply to:</th><td class="field-body"><p class="first">is the message id of the message that this is a reply to.</p>
<p>This shall be set to 0 unless this message <em>is</em> a reply to a previous
message. In other words, if this value is non-0, then the message <em>is</em> a
reply.</p>
</td>
</tr>
<tr class="field"><th class="field-name">to:</th><td class="field-body"><p class="first">is the KSock id identifying who the message is to be sent to.</p>
<p>When writing a new message, this should normally be set to 0, meaning
&quot;anyone listening&quot; (but see below if &quot;state&quot; is being maintained).</p>
<p>When replying to a message, it shall be set to the 'from' value of the
orginal message.</p>
<p>When constructing a request message (a message wanting a reply), then it can
be set to a specific replier's KSock id. When such a message is sent, if the
replier bound (at that time) does not have that specific KSock id, then the
send will fail.</p>
</td>
</tr>
<tr class="field"><th class="field-name">from:</th><td class="field-body"><p class="first">indicates the KSock id of the message's sender.</p>
<p>When writing a new message, set this to 0, since KBUS will set it.</p>
<p>When reading a message, this will have been set by KBUS.</p>
</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body"><p class="first">indicates extra information about the message. See <a class="reference" href="#message-flags">Message Flags</a>
for detailed information.</p>
<p>When writing a message, this can be used to indicate that</p>
<ul class="simple">
<li>the message is URGENT</li>
<li>a reply is wanted</li>
</ul>
<p>When reading a message, this indicates:</p>
<ul class="last simple">
<li>the message is URGENT</li>
<li>a reply is wanted</li>
<li>a reply is wanted from the specific reader</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id12" id="the-message-body" name="the-message-body">The message body</a></h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">name length:</th><td class="field-body"><p class="first">is the length of the message name in bytes.</p>
<p>When writing a new message, this must be non-zero.</p>
<p>When replying to a message, this must be non-zero - i.e., the message name
must still be given - although it is possible that this may change in the
future.</p>
<blockquote>
<p>Note: in future implementations, a message name code (an integer
representing the particular message name) may be used instead of a
message name, and this field may be hijacked for that purpose, depending
on flags, etc.</p>
</blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">data length:</th><td class="field-body"><p class="first last">is the length of the message data, in 32-bit words. It may be zero
if there is no data associated with this message.</p>
</td>
</tr>
</tbody>
</table>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Remember that the message name length is in <em>bytes</em> and the
message data length is in <em>32-bit words</em>.</p>
</div>
<p>These are followed by the message name and then the message data (if any).</p>
<ul class="simple">
<li>The message name must be padded out to a multiple of 4 bytes.  This is not
indicated in the message length, which should give the actual number of
characters in the message name. Padding should be with zero bytes (but it
is not necessary for there to be a zero byte at the end of the name). Byte
ordering is according to that of the platform.</li>
<li>The data is not touched by KBUS, and is just copied as given.</li>
</ul>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id13" id="message-flags" name="message-flags">Message flags</a></h2>
<p>The WANT_A_REPLY bit is set by the sender to indicate that a
reply is wanted. This makes the message into a request.</p>
<blockquote>
Note that setting the WANT_A_REPLY bit (i.e., a request) and
setting 'in_reply_to' (i.e., a reply) is bound to lead to
confusion, and the results are undefined (i.e., don't do it).</blockquote>
<p>The WANT_YOU_TO_REPLY bit is set by KBUS on a particular message
to indicate that the particular recipient is responsible for replying
to (this instance of the) message. Otherwise, KBUS clears it.</p>
<p>The SYNTHETIC bit is set by KBUS when it generates a Status message, for
instance when a replier has gone away and will therefore not be sending a
reply to a request that has already been queued.</p>
<blockquote>
Note that KBUS does not check that a sender has not set this
flag on a message, but doing so may lead to confusion.</blockquote>
<p>The URGENT bit is set by the sender if this message is to be
treated as urgent - i.e., it should be added to the <em>front</em> of the
recipient's message queue, not the back.</p>
<div class="section">
<h3><a class="toc-backref" href="#id14" id="send-flags" name="send-flags">Send flags</a></h3>
<p>There are two &quot;send&quot; flags, ALL_OR_WAIT and ALL_OR_FAIL.
Either one may be set, or both may be unset.</p>
<blockquote>
<p>If both are set, the message will be rejected as invalid.</p>
<p>Both flags are ignored in reply messages (i.e., messages with the
'in_reply_to' field set).</p>
</blockquote>
<p>If a message has ALL_OR_FAIL set, then a SEND will only succeed if the message
could be added to all the (intended) recipient's message queues. Otherwise,
SEND returns -EBUSY.</p>
<p>If a message has ALL_OR_WAIT set, then a SEND will only succeed if the message
could be added to all the (intended) recipient's message queues. Otherwise
SEND returns -EAGAIN. In this case, the message is still being sent, and the
caller should either call DISCARD (to drop it), or else use poll/select to
wait for the send to finish. It will not be possible to call &quot;write&quot; until the
send has completed or been discarded.</p>
<p>These are primarily intended for use in debugging systems. In particular, note
that the mechanisms dealing with ALL_OR_WAIT internally are unlikely to be
very efficient.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="things-kbus-changes-in-a-message" name="things-kbus-changes-in-a-message">Things KBUS changes in a message</a></h2>
<p>In general, KBUS leaves the content of a message alone - mostly so that an
individual KBUS module can &quot;pass through&quot; messages from another domain.
However, it does change:</p>
<ul class="simple">
<li>the message id's serial number (but only if its network id is unset)</li>
<li>the 'from' id (to indicate the KSock this message was sent from)</li>
<li>the WANT_YOU_TO_REPLY bit in the flags (set or cleared as appropriate)</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id16" id="types-of-message" name="types-of-message">Types of message</a></h1>
<p>There are four basic message types:</p>
<ul class="simple">
<li>Announcement -- a message aimed at any listeners, expecting no reply</li>
<li>Request -- a message aimed at a replier, who is expected to reply</li>
<li>Reply -- a reply to a request</li>
<li>Status -- a message generated by KBUS</li>
</ul>
<p>The Python interface provides a Message base class, and subclasses thereof for
each of the &quot;user&quot; message types (but not currently for Status).</p>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="announcements" name="announcements">Announcements</a></h2>
<p>An announcement is the &quot;plain&quot; message type. It is a message that is being
sent for all bound listeners to &quot;hear&quot;.</p>
<p>When creating a new announcement message, it has:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">message id:</th><td class="field-body">see <a class="reference" href="#message-ids">Message ids</a></td>
</tr>
<tr class="field"><th class="field-name">in reply to:</th><td class="field-body">unset (it's not a reply)</td>
</tr>
<tr class="field"><th class="field-name">to:</th><td class="field-body">unset (all announcements are broadcast to any listeners)</td>
</tr>
<tr class="field"><th class="field-name">from:</th><td class="field-body">unset (KBUS will set it)</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body">typically unset, see <a class="reference" href="#message-flags">Message flags</a></td>
</tr>
<tr class="field"><th class="field-name">message name:</th><td class="field-body">as appropriate</td>
</tr>
<tr class="field"><th class="field-name">message data:</th><td class="field-body">as appropriate</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The Python interface provides an <tt class="docutils literal"><span class="pre">Announcement</span></tt> class to help in creating an
announcement message.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="request-message" name="request-message">Request message</a></h2>
<p>A request message is a message that wants a reply.</p>
<p>Since only one KSock may bind as a replier for a given message name, a
request message wants a reply from a single KSock. By default, this is
whichever KSock has bound to the message name at the moment of sending, but
see <a class="reference" href="#stateful-transactions">Stateful transactions</a>.</p>
<p>When creating a new request message, it has:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">message id:</th><td class="field-body">see <a class="reference" href="#message-ids">Message ids</a></td>
</tr>
<tr class="field"><th class="field-name">in reply to:</th><td class="field-body">unset (it's not a reply)</td>
</tr>
<tr class="field"><th class="field-name">to:</th><td class="field-body">either unset, or a specific KSock id if the request
should fail if that KSock is (no longer) the replier
for this message name</td>
</tr>
<tr class="field"><th class="field-name">from:</th><td class="field-body">unset (KBUS will set it)</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body">the &quot;needs a reply&quot; flags should be set.
KBUS will set the &quot;you need to reply&quot; flag in the
copy of the message delivered to its replier.</td>
</tr>
<tr class="field"><th class="field-name">message name:</th><td class="field-body">as appropriate</td>
</tr>
<tr class="field"><th class="field-name">message data:</th><td class="field-body">as appropriate</td>
</tr>
</tbody>
</table>
</blockquote>
<p>When receiving a request message, the WANT_YOU_TO_REPLY flag will be set if it
is this recipient's responsibility to reply.</p>
<p>The Python interface provides a <tt class="docutils literal"><span class="pre">Request</span></tt> class to help in creating a
request message.</p>
<p>When a request message is sent, it is an error if there is no replier bound to
that message name.</p>
<p>The message will, as normal, be delivered to all listeners, and will have the
&quot;needs a reply&quot; flag set wherever it is received. However, only the copy of
the message received by the replier will be marked with the WANT_YOU_TO_REPLY
flag.</p>
<blockquote>
So, if a particular file descriptor is bound as listener and replier
for '$.Fred', it will receive two copies of the original message (one
marked as needing reply from that file descriptor). However, when the
reply is sent, only the &quot;plain&quot; listener will receive a copy of the reply
message.</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="reply-message" name="reply-message">Reply message</a></h2>
<p>A reply message is the expected response after reading a request message.</p>
<p>A reply message is distinguished by having a non-zero 'in reply to' value.</p>
<p>Each reply message is in response to a specific request, as indicated by the
'in reply to' field in the message.</p>
<p>The replier is helped to remember that it needs to reply to a request, because
the request has the WANT_YOU_TO_REPLY flag set.</p>
<p>When a reply is sent, all listeners for that message name will receive it.
However, the original replier will not.</p>
<p>When creating a new reply message, it has:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">message id:</th><td class="field-body">see <a class="reference" href="#message-ids">Message ids</a></td>
</tr>
<tr class="field"><th class="field-name">in reply to:</th><td class="field-body">the request message's 'message id'</td>
</tr>
<tr class="field"><th class="field-name">to:</th><td class="field-body">the request message's 'from' id</td>
</tr>
<tr class="field"><th class="field-name">from:</th><td class="field-body">unset (KBUS will set it)</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body">typically unset, see <a class="reference" href="#message-flags">Message flags</a></td>
</tr>
<tr class="field"><th class="field-name">message name:</th><td class="field-body">the request message's 'message name'</td>
</tr>
<tr class="field"><th class="field-name">message data:</th><td class="field-body">as appropriate</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The Python interface provides a <tt class="docutils literal"><span class="pre">Reply</span></tt> class to help in creating a reply
message, but more usefully there is also a <tt class="docutils literal"><span class="pre">reply_to</span></tt> function that creates
a Reply Message from the original Request.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="status-message" name="status-message">Status message</a></h2>
<p>KBUS generates Status messages (also sometimes referred to as &quot;synthetic&quot;
messages) when a request message has been successfully sent, but the replier
is unable to reply (for instance, because it has closed its KSock). KBUS thus
uses a Status message to provide the &quot;reply&quot; that it guarantees the sender
will get.</p>
<p>As you might expect, a KBUS status message is thus (technically) a reply
message.</p>
<p>A status message looks like:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">message id:</th><td class="field-body">as normal</td>
</tr>
<tr class="field"><th class="field-name">in reply to:</th><td class="field-body">the 'message id' of the message whose sending or
processing caused this message.</td>
</tr>
<tr class="field"><th class="field-name">to:</th><td class="field-body">the KSock id of the recipient of the message</td>
</tr>
<tr class="field"><th class="field-name">from:</th><td class="field-body">the KSock id of the sender of the message - this will
be 0 if the sender is KBUS itself (which is assumed for
most exceptions)</td>
</tr>
<tr class="field"><th class="field-name">flags:</th><td class="field-body">typically unset, see <a class="reference" href="#message-flags">Message flags</a></td>
</tr>
<tr class="field"><th class="field-name">message name:</th><td class="field-body">for KBUS exceptions, a message name in '$.KBUS.*'</td>
</tr>
<tr class="field"><th class="field-name">message data:</th><td class="field-body">for KBUS exceptions, normally absent</td>
</tr>
</tbody>
</table>
</blockquote>
<p>KBUS status messages always have '$.KBUS.&lt;something&gt;' names (this may be a
multi-level &lt;something&gt;), and are always in response to a previous message, so
always have an 'in reply to'.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="requests-and-replies" name="requests-and-replies">Requests and Replies</a></h2>
<p>KBUS guarantees that each Request will (eventually) be matched by a consequent
Reply (or Status <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a>) message, and only one such.</p>
<p>The &quot;normal&quot; case is when the replier reads the request, and sends its own
reply back.</p>
<p>If a Request message has been successfully SENT, there are the following other
cases to consider:</p>
<ol class="arabic simple">
<li>The replier unbinds from that message name before reading the request
message from its queue. In this case, KBUS removes the message from the
repliers queue, and issues a &quot;$.KBUS.Replier.Unbound&quot; message.</li>
<li>The replier closes itself (close the KSock), but has not yet read the
message. In this case, KBUS issues a &quot;$.KBUS.Replier.GoneAway&quot; message.</li>
<li>The replier closes itself (closes the KSock), has read the message, but has
not yet (and now cannot) replied to it. In this case, KBUS issues a
&quot;$.KBUS.Replier.Ignored&quot; message.</li>
<li>SEND did not complete, and the replier closes itself before the message can
be added to its message queue (by the POLL mechanism). In this case, KBUS
issues a &quot;$.KBUS.Replier.Disappeared&quot; message.</li>
<li>SEND did not complete, and an error occurs when the POLL mechanims tries to
send the message. In this case, KBUS issues a &quot;$.KBUS.ErrorSending&quot;
message.</li>
</ol>
<p>In all these cases, the 'in_reply_to' field is set to the original request's
message id. In the first three cases, the 'from' field will be set to the
KSock id of the (originally intended) replier. In the last two cases, that
information is not available, and a 'from' of 0 (indicating KBUS itself) is
used.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>Remember that a Status message is essentially a specialisation of a
Reply message.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id22" id="kbus-end-points-ksocks" name="kbus-end-points-ksocks">KBUS end points - KSocks</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="the-kbus-devices" name="the-kbus-devices">The KBUS devices</a></h2>
<p>Message interactions happen via the KBUS devices. Installing the KBUS kernel
module always creates <tt class="docutils literal"><span class="pre">/dev/kbus0</span></tt>, it may also create <tt class="docutils literal"><span class="pre">/dev/kbus1</span></tt>, and
so on.</p>
<blockquote>
<p>The number of devices to create is indicated by an argument at module
installation, for instance:</p>
<pre class="literal-block">
# insmod kbus.ko num_kbus_devices=10
</pre>
</blockquote>
<p>Messages are sent by writing to a KBUS device, and received by reading from
the same device. A variety of useful ioctls are also provided. Each KBUS
device is independent - messages cannot be sent from <tt class="docutils literal"><span class="pre">/dev/kbus0</span></tt> to
<tt class="docutils literal"><span class="pre">/dev/kbus1</span></tt>, since there is no shared information.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="ksocks" name="ksocks">KSocks</a></h2>
<p>Specifically, messages are written to and read from KBUS device file
descriptors. Each such is termed a <em>KSock</em> - this is a simpler term than &quot;file
descriptor&quot;, and has some resonance with &quot;socket&quot;.</p>
<p>Each KSock may be any (one or more) of:</p>
<ul class="simple">
<li>a Sender (opening the device for read/write)</li>
<li>a Listener (only needing to open the device for read)</li>
<li>a Replier (opening the device for read/write)</li>
</ul>
<p>Every KSock has an id. This is a 32-bit unsigned number assigned by KBUS when
the device is opened. The value 0 is reserved for KBUS itself.</p>
<blockquote>
The terms &quot;listener id&quot;, &quot;sender id&quot;, &quot;replier id&quot;, etc., thus all refer
to a KSock id, depending on what it is being used for.</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="senders" name="senders">Senders</a></h2>
<p>Message senders are called &quot;senders&quot;. A sender should open a KSock for read
and write, as it may need to read replies and error/status messages.</p>
<p>A message is sent by:</p>
<ol class="arabic">
<li><p class="first">Writing the message to the KSock (using the standard <tt class="docutils literal"><span class="pre">write</span></tt> function)</p>
</li>
<li><p class="first">Calling the SEND ioctl on the KSock, to actually send the message. This
returns (via its arguments) the message id of the message sent. It also
returns status information about the send</p>
<blockquote>
<p>The status information is to be documented.</p>
</blockquote>
</li>
</ol>
<p>The DISCARD ioctl can be used to &quot;throw away&quot; a partially written message,
before SEND has been called on it.</p>
<p>If there are no listeners (of any type) bound to that message name, then the
message will be ignored.</p>
<p>If the message is flagged as needing a reply, and there are no repliers bound
to that message name, then an error message will be sent to the sender, by
KBUS.</p>
<p>It is not possible to send a message with a wildcard message name.</p>
<blockquote>
As a restriction this makes the life of the implementor and documentor
easier. I believe it would also be confusing if provided.</blockquote>
<p>The sender does not need to bind to any message names in order to receive
error and status messages from KBUS.</p>
<p>When a sender sends a Request, an internal note is made that it expects a
corresponding Reply (or possible a Status message from KBUS if the Replier
goes away or unbinds from that message name, before replying). A place for
that Reply is reserved in the sender's message queue. If the message queue
fills up (either with messages waiting to be read, or with reserved slots for
Replies), then the sender will not be able to send another Request until there
is room on the message queue again.</p>
<blockquote>
Hopefully, this can be resolved by the sender reading a message off its
queue. However, if there are no messages to be read, and the queue is all
reserved for replies, the only solution is for the sender to wait for a
replier to send it something that it can then read.</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p>What order do we describe things in? Don't forget:</p>
<p>If the message being sent is a request, then the replier bound to that
message name will (presumably) write a reply to the request. Thus the normal
sequence for a request is likely to be:</p>
<ol class="arabic simple">
<li>write the request message</li>
<li>read the reply</li>
</ol>
<p>The sender does <em>not</em> need to bind to anything in order to receive a reply to
a request it has sent.</p>
<blockquote class="last">
Of course, if a sender binds to listen to the name it uses for its
request, then it will get a copy of the request as sent, and it will
also get (an extra) copy of the reply.</blockquote>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="listeners" name="listeners">Listeners</a></h2>
<p>Message recipients are called &quot;listeners&quot;.</p>
<p>Listeners indicate that they want to receive particular messages, by using the
BIND ioctl on a KSock to specify the name of the message that is to be
listened for. If the binding is to a wildcarded message name, then the
listener will receive all messages with names that match the wildcard.</p>
<p>An ordinary listener will receive all messages with that name (sent to the
relevant KSock). A listener may make more than one binding on the same KSock
(indeed, it is allowed to bind to the same name more than once).</p>
<p>Messages are received by:</p>
<ol class="arabic simple">
<li>Using the NEXT_MSG ioctl to request the next message (this also returns the
messages length in bytes)</li>
<li>Calling the standard <tt class="docutils literal"><span class="pre">read</span></tt> function to read the message data.</li>
</ol>
<p>If NEXT_MSG is called again, the next message will be readied for reading,
whether the previous message has been read (or partially read) or not.</p>
<p>If a listener no longer wants to receive a particular message name, then they
can unbind from it, using the UNBIND ioctl. The message name and flags used in
an UNBIND must match those in the corresponding BIND. Any messages in the
listener's message queue which match that unbinding will be removed from the
queue (i.e., the listener will not actually receive them). This does <em>not</em>
affect the message currently being read.</p>
<blockquote>
Note that this has implication for binding and unbinding wildcards,
which must also match.</blockquote>
<p>Closing the KSock also unbinds all the message bindings made on it.
It does not affect message bindings made on other KSocks.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="repliers" name="repliers">Repliers</a></h2>
<p>Repliers are a special sort of listener.</p>
<p>For each message name, there may be a single &quot;replier&quot;. A replier binds to a
message name in the same way as any other listener, but sets the &quot;replier&quot;
flag. If someone else has already bound to the same KSock as a replier for
that message name, the request will fail.</p>
<p>Repliers only receive Requests (messages that are marked as wanting a reply).</p>
<p>A replier may (should? must?) reply to the request - this is done by sending
a Reply message through the KSock from which the Request was read.</p>
<p>It is perfectly legitimate to bind to a message as both replier and listener,
in which case two copies of the message will be read, once as replier, and
once as (just) listener.</p>
<p>When a request message is read by the appropriate replier, KBUS will mark
<em>that particular message</em> with the &quot;you must reply&quot; flag. This will not be set
on copies of that message read by any (non-replier) listeners.</p>
<blockquote>
So, in the case where a KSock is bound as replier and listener for the
same message name, only one of the two copies of the message received will
be marked as &quot;you must reply&quot;.</blockquote>
<p>If a replier binds to a wildcarded message name, then they are the <em>default</em>
replier for any message names satisfying that wildcard. If another replier
binds to a more specific message name (matching that wildcard),
then the specific message name binding &quot;wins&quot; - the wildcard replier will no
longer receive that message name.</p>
<blockquote>
In particular '$.Fred.Jim' is more specific than '$.Fred.%' which in turn
is more specific than '$.Fred.*'</blockquote>
<p>This means that if a wildcard replier wants to guarantee to see all the
messages matching their wildcard, they also need to bind as a listener for the
same wildcarded name.</p>
<blockquote>
<p>Example:</p>
<p>Assume message names are of the form '$.Sensors.&lt;Room&gt;' or
'$.Sensors.&lt;Room&gt;.&lt;Measurement&gt;'.</p>
<p>Replier 1 binds to '$.Sensors.*'. They will be the default replier for
all sensor requests.</p>
<p>Replier 2 binds to '$.Sensors.%'. They will take over as the default
replier for any room specific requests.</p>
<p>Replier 3 binds to '$.Sensors.Kitchen.Temperature'. They will take over as
the replier for the kitchen temperature.</p>
<p>So:</p>
<ul class="simple">
<li>A message named '$.Sensors.Kitchen.Temperature' will go to replier 3.</li>
<li>A message named '$.Sensors.Kitchen' or '$.Sensors.LivingRoom' will go to
replier 2.</li>
<li>A message named '$.Sensors.LivingRoom.Temperature' will go to replier 1.</li>
</ul>
</blockquote>
<p>When a Replier is closed (technically, when its <tt class="docutils literal"><span class="pre">release</span></tt> function is
called by the kernel) KBUS traverses its outstanding message queue, and for
each Request that has not been answered, generates a Status message saying
that the Replier has &quot;GoneAway&quot;.</p>
<p>Similarly, if a Replier unbinds from replying to a mesage, KBUS traverses its
outstanding message queue, and for each Request that has not been answered, it
generates a Status message saying that it has &quot;Unbound&quot; from being a replier
for that message name. It also forgets the message, which it is now not going
to reply to.</p>
<p>Lastly, when a Replier is closed, if it has read any Requests (technically,
called NEXTMSG to pop them from the message queue), but not actually replied
to them, then KBUS will send an &quot;Ignored&quot; Status message for each such
Request.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id28" id="more-information" name="more-information">More information</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="stateful-transactions" name="stateful-transactions">Stateful transactions</a></h2>
<p>It is possible to make stateful message transactions, by:</p>
<ol class="arabic simple">
<li>sending a Request</li>
<li>receiving the Reply, and noting the KSock id of the replier</li>
<li>sending another Request to that specific replier</li>
<li>and so on</li>
</ol>
<p>Sending a request to a particular KSock will fail if that KSock is no longer
bound as replier to the relevant message name. This allows a sender to
guarantee that it is communicating with a particular instance of the replier
for a message name.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="queues-filling-up" name="queues-filling-up">Queues filling up</a></h2>
<p>Messages are sent by a mechanism which:</p>
<ol class="arabic simple">
<li>Checks the message is plausible (it has a plausible message name,
and the right sort of &quot;shape&quot;)</li>
<li>If the message is a Request, checks that the sender has room on its message
queue for the (eventual) Reply.</li>
<li>Finds the KSock ids of all the listeners and repliers bound to that
messages name</li>
<li>Adds the message to the queue for each such listener/replier</li>
</ol>
<p>This can cause problems if one of the queues is already full (allowing
infinite expansion of queues would also cause problems, of couse).</p>
<p>If a <em>sender</em> attempts to send a Request, but does not have room on its
message queue for the (corresponding) Reply, then the message will not be
sent, and the send will fail. Note that the message id will not be set, and
the blocking behaviours defined below do not occur.</p>
<p>If a <em>replier</em> cannot receive a particular message, because its queue is full,
then the message will not be sent, and the send will fail with an error. This
does, however, set the message id (and thus the &quot;last message id&quot; on the
sender).</p>
<p>Moreover, a sender can indicate if it wants a message to be:</p>
<ol class="arabic simple">
<li>Added to all the listener queues, regardless, in which case it will block
until that can be done (ALL_OR_WAIT, sender blocks)</li>
<li>Added to all the listener queues, and fail if that can't be done
(ALL_OR_FAIL)</li>
<li>Added to all the listener queues that have room (the default)</li>
</ol>
<p>See <a class="reference" href="#message-flags">Message flags</a> for more details.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="urgent-messages" name="urgent-messages">Urgent messages</a></h2>
<p>Messages may be flagged urgent. In this case they will be added to the front
of the destination message queue, rather than the end - in other words, they
will be the next message to be &quot;popped&quot; by NEXTMSG.</p>
<p>Note that this means that if two urgent messages are sent to the same target,
and <em>then</em> a NEXTMSG/read occurs, the second urgent message will be popped and
read first.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="select-write-send-and-next-message-blocking" name="select-write-send-and-next-message-blocking">Select, write/send and &quot;next message&quot;, blocking</a></h2>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">At the moment, <tt class="docutils literal"><span class="pre">read</span></tt> and <tt class="docutils literal"><span class="pre">write</span></tt> are always non-blocking.</p>
</div>
<p><tt class="docutils literal"><span class="pre">read</span></tt> returns more of the currently selected message, or EOF if there is no
more of that message to read (and thus also if there is no currently selected
message). The NEXTMSG ioctl is used to select (&quot;pop&quot;) the next message.</p>
<p><tt class="docutils literal"><span class="pre">write</span></tt> writes to the end of the currently-being-written message. The
DISCARD ioctl can be used to discard the data written so far, and the SEND
ioctl to send the (presumably completed message). Whilst the message is being
sent, it is not possible to use <tt class="docutils literal"><span class="pre">write</span></tt>.</p>
<p>Note that if SEND is used to send a Request, then KBUS ensures that there will
always be either a Reply or a Status message in response to that request.</p>
<p>Specifically, if:</p>
<ol class="arabic simple">
<li>The Replier &quot;goes away&quot; (and its &quot;release&quot; function is called) before
reading the Request (specifically, before calling NEXTMSG to pop it from
the message queue)</li>
<li>The Replier &quot;goes away&quot; (and its &quot;release&quot; function is called) before
replying to a Request that it has already read (i.e., used NEXTMSG to pop
from the message queue)</li>
<li>The Replier unbinds from that Request message name before reading the
Request (with the same caveat on what that means)</li>
<li>Select/poll attempts to send the Request, and discovers that the
Replier has disappeared since the initial SEND</li>
<li>Select/poll attempts to send the Request, and some other error occurs</li>
</ol>
<p>then KBUS will &quot;reply&quot; with an appropriate Status message.</p>
<hr class="docutils" />
<p>KBUS support its own particular variation on blocking of message sending.</p>
<p>First of all, it supports use of &quot;select&quot; to determine if there are any
messages waiting to be read. So, for instance (in Python):</p>
<pre class="literal-block">
with KSock(0,'rw') as sender:
    with KSock(0,'r') as listener:
        (r,w,x) = select.select([listener],[],[],0)
        assert r == []

        listener.bind('$.Fred')
        msg = Announcement('$.Fred','data')
        sender.send_msg(msg)

        (r,w,x) = select.select([listener],[],[],0)
        assert r == [listener]
</pre>
<p>This simply checks if there is a message in the KSock's message list, waiting
to be &quot;popped&quot; with NEXTMSG.</p>
<p>Secondly, <tt class="docutils literal"><span class="pre">write</span></tt>, SEND and DISCARD interact in what is hoped to be a
sensible manner. Specifically:</p>
<ul class="simple">
<li>When SEND (i.e., the SEND ioctl) is called, KBUS can either:<ol class="arabic">
<li>Succeed in sending the message. The KSock is now ready for <tt class="docutils literal"><span class="pre">write</span></tt> to
be called on it again.</li>
<li>Failed in sending the message (possibly, if the message was a Request,
with EADDRNOTAVAIL, indicating that there is no Replier for that
Request). The KSock is now ready for <tt class="docutils literal"><span class="pre">write</span></tt> to be called on it again.</li>
<li>If the message was marked ALL_OR_WAIT, then it may fail with EAGAIN.
In this case, the KSock is still in sending state, and an attempt to
call <tt class="docutils literal"><span class="pre">write</span></tt> will fail (with EALREADY). The caller can either use
DISCARD to discard the message, or use select/poll to wait for the
message to finish sending.</li>
</ol>
</li>
</ul>
<p>Thus &quot;select&quot; for the write case checks whether it is allowed to call
&quot;write&quot; - for instance:</p>
<pre class="literal-block">
with KSock(0,'rw') as sender:
    write_list = [sender]
    with KSock(0,'r') as listener1:
        write_list= [sender,listener1]
        read_list = [listener1]

        (r,w,x) = select.select(read_list,write_list,[],0)
        assert r == []
        assert w == [sender]
        assert x == []

        with KSock(0,'rw') as listener2:
            write_list.append(listener2)
            read_list.append(listener2)

            (r,w,x) = select.select(read_list,write_list,[],0)
            assert r == []
            assert len(w) == 2
            assert sender in w
            assert listener2 in w
            assert x == []
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="ioctls" name="ioctls">IOCTLS</a></h2>
<p>The KBUS ioctls are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">RESET:</th><td class="field-body">Currently has no effect</td>
</tr>
<tr class="field"><th class="field-name">BIND:</th><td class="field-body">Bind to a particular message name (possibly as replier).</td>
</tr>
<tr class="field"><th class="field-name">UNBIND:</th><td class="field-body">Unbind from a binding - must match exactly.</td>
</tr>
<tr class="field"><th class="field-name">KSOCKID:</th><td class="field-body">Determine the KSock id of the KSock used</td>
</tr>
<tr class="field"><th class="field-name">REPLIER:</th><td class="field-body">Determine who is bound as replier to a particular message
name. This returns 0 or the KSock id of the replier.</td>
</tr>
<tr class="field"><th class="field-name">NEXTMSG:</th><td class="field-body">Pop the next message from the KSock's message queue, ready
for reading (with <tt class="docutils literal"><span class="pre">read</span></tt>), and return its length (in bytes).
If there is no next message, return a length of 0.</td>
</tr>
<tr class="field"><th class="field-name">LENLEFT:</th><td class="field-body">Determine how many bytes of the message currently being read
are still to read.</td>
</tr>
<tr class="field"><th class="field-name">SEND:</th><td class="field-body">Send the current outstanding message for this KSock (i.e., the
bytes written to the KSock since the last SEND or DISCARD).
Return the message id of the message, and maybe other status
information.</td>
</tr>
<tr class="field"><th class="field-name">DISCARD:</th><td class="field-body">Discard (throw away) the current outstanding message for this
KSock (i.e., any bytes written to the KSock since the last
SEND or DISCARD).</td>
</tr>
<tr class="field"><th class="field-name">LASTSENT:</th><td class="field-body">Determine the message id of the last message SENT on this
KSock.</td>
</tr>
<tr class="field"><th class="field-name">MAXMSGS:</th><td class="field-body">Set the maximum length of the (read) message queue for this
KSOCK, and return the actual length that is set. An attempt
to set the queue length to 0 will just return the current
queue length.</td>
</tr>
<tr class="field"><th class="field-name">NUMMSGS:</th><td class="field-body">Determine how many messages are outstanding in this KSock's
read queue.</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="proc-kbus-bindings" name="proc-kbus-bindings">/proc/kbus/bindings</a></h2>
<p><tt class="docutils literal"><span class="pre">/proc/kbus/bindings</span></tt> is a debugging aid for reporting the listener id,
exclusive flag and message name for each binding, for each kbus device.</p>
<p>An example might be:</p>
<pre class="literal-block">
$ cat /proc/kbus/bindings
 1: 1 R $.Sensors.*
 1: 2 R $.Sensors.Kitchen.Temperature
 1: 3 L $.Sensors.*
13: 4 L $.Jim.*
13: 1 R $.Fred
13: 1 L $.Jim
13: 14 L $.Jim.*
</pre>
<p>This describes two KBUS devices (<tt class="docutils literal"><span class="pre">/dev/kbus1</span></tt> and <tt class="docutils literal"><span class="pre">/dev/kbus13</span></tt>).</p>
<p>The first has bindings on KSock ids 1, 2 and 3, for the given message names. The
&quot;R&quot; indicates a replier binding, the &quot;L&quot; indicates a listener (non-replier)
binding.</p>
<p>The second has bindings on KSock ids 4, 1 and 14. The order of the bindings
reported is <em>not</em> particularly significant.</p>
<p>Note that there is no communication between the two devices, so KSock id 1 on
device 1 is not related to (and has no commonality with) KSock id 1 on device
13.</p>
<p>The current implementation of the <tt class="docutils literal"><span class="pre">/proc/kbus/bindings</span></tt> interface is very
simplistic. If the data approaches the size of a kernel page, then the data
output will be truncated, and the last line will be <tt class="docutils literal"><span class="pre">...</span></tt>. This may be
improved (one can hope) in a future version of KBUS.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="proc-kbus-stats" name="proc-kbus-stats">/proc/kbus/stats</a></h2>
<p><tt class="docutils literal"><span class="pre">/proc/kbus/stats</span></tt> is a debugging aid for reporting various statistics about
the KBUS devices and the KSocks open on them.</p>
<p>An example might be:</p>
<pre class="literal-block">
$ cat /proc/kbus/stats
dev  0: next file 5 next msg 8
        ksock 4 last msg 0:7 queue 1 of 100
            read: 0 of 0, write 52 (max 60), sending
            outstanding requests 0 (max 16), replies 0
        ksock 3 last msg 0:5 queue 0 of 1
            read: 0 of 0, write 0 (max 0), not sending
            outstanding requests 1 (max 16), replies 0
</pre>
<p>or:</p>
<pre class="literal-block">
$ cat /proc/kbus/stats
dev  0: next file 1002 next msg 0
        ksock 1001 last msg 0:0 queue 0 of 100
              read: 0 of 0, write 0 (max 0), not sending
              outstanding requests 0 (max 16), replies 0
        ksock 1000 last msg 0:0 queue 0 of 100
              read: 0 of 0, write 0 (max 0), not sending
              outstanding requests 0 (max 16), replies 0
        ksock 999 last msg 0:0 queue 0 of 100
              read: 0 of 0, write 0 (max 0), not sending
              outstanding requests 0 (max 16), replies 0
        ksock 998 last msg 0:0 queue 0 of 100
              read: 0 of 0, write 0 (max 0), not sending
              outstanding requests 0 (max 16), replies 0
        ksock 997 last msg 0:0 queue 0 of 100
              read: 0 of 0, write 0 (max 0), not sending
              outstanding requests 0 (max 16), replies 0
...
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="error-numbers" name="error-numbers">Error numbers</a></h2>
<p>The following error numbers get special use. In Python, they are all returned
as values inside the IOError exception.</p>
<blockquote>
Since we're trying to fit into the normal Un*x convention that negative
values are error numbers, and since Un*x defines many of these for us,
it is natural to make use of the relevant definitions. However, this also
means that we are often using them in an unnatural sense. I've tried to
make the error numbers used bear at least a vague relationship to their
(mis)use in KBUS.</blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">EADDRINUSE:</th><td class="field-body"><p class="first">On attempting to bind a message name as replier: There is
already a replier bound for this message</p>
</td>
</tr>
<tr class="field"><th class="field-name">EADDRNOTAVAIL:</th><td class="field-body"><p class="first">On attempting to send a Request message: There is no replier
bound for this message's name.</p>
</td>
</tr>
<tr class="field"><th class="field-name">EALREADY:</th><td class="field-body"><p class="first">On attempting to write to a KSock, when a previous send has
returned EAGAIN. Either DISCARD the message, or use
select/poll to wait for the send to complete, and write to be
allowed.</p>
</td>
</tr>
<tr class="field"><th class="field-name">EBADMSG:</th><td class="field-body"><p class="first">On attempting to bind, unbind or send a message: The message
name is not valid. On sending, this can also be because the
message name is a wildcard.</p>
</td>
</tr>
<tr class="field"><th class="field-name">EBUSY:</th><td class="field-body"><p class="first">On attempting to send, then:</p>
<ol class="arabic simple">
<li>For a request, the replier's message queue is full.</li>
<li>For any message, with ALL_OR_FAIL set, one of the
targetted listener/replier queues was full.</li>
</ol>
</td>
</tr>
<tr class="field"><th class="field-name">ECONNREFUSED:</th><td class="field-body"><p class="first">On attempting to send a Reply, the intended recipient (the
notional original sender of the Request) is not expecting
a Reply with that message id in its 'in_reply_to'. Or, in
other words, this appears to be an attempt to reply to the
wrong message id or the wrong KSock.</p>
</td>
</tr>
<tr class="field"><th class="field-name">EINVAL:</th><td class="field-body"><p class="first">Something went wrong (generic error).</p>
</td>
</tr>
<tr class="field"><th class="field-name">EMSGSIZE:</th><td class="field-body"><p class="first">On attempting to write or send a message: The message data is
too long.</p>
</td>
</tr>
<tr class="field"><th class="field-name">ENAMETOOLONG:</th><td class="field-body"><p class="first">On attempting to bind, unbind or send a message: The message
name is too long.</p>
</td>
</tr>
<tr class="field"><th class="field-name">ENOENT:</th><td class="field-body"><p class="first">On attempting to open a KSock: There is no such device
(normally because one has tried to open, for instance,
'/dev/kbus9' when there are only 3 KBUS devices).</p>
</td>
</tr>
<tr class="field"><th class="field-name">ENOLCK:</th><td class="field-body"><p class="first">On attempting to send a Request, when there is not enough room
in the sender's message queue to guarantee that it can
receive a reply for every Request already sent, <em>plus</em> this
one. If there are oustanding messages in the sender's message
queue, then the solution is to read some of them. Otherwise,
the sender will have to wait until one of the Repliers
replies to a previous Request (or goes away and KBUS replies
for it).</p>
<p>When this error is received, the send has failed (just as if
the message was invalid). The sender is not left in &quot;sending&quot;
state, nor has the message been assigned a message id.</p>
<p>Note that this is <em>not</em> EAGAIN, since we do not want to block
the sender (in the SEND) if it is up to the sender to perform
a read to sort things out.</p>
</td>
</tr>
<tr class="field"><th class="field-name">ENOMSG:</th><td class="field-body"><p class="first">On attempting to send, when there is no message waiting to be
sent (either because there has been no write since the last
send, or because the message being written has been
discarded).</p>
</td>
</tr>
<tr class="field"><th class="field-name">EPIPE:</th><td class="field-body"><p class="first last">On attempting to send 'to' a specific replier, the replier
with that id is no longer bound to the given message's name.</p>
</td>
</tr>
</tbody>
</table>
<!-- Local Variables: -->
<!-- tab-width: 8 -->
<!-- indent-tabs-mode: nil -->
<!-- c-basic-offset: 2 -->
<!-- End: -->
<!-- vim: set filetype=rst tabstop=8 shiftwidth=2 expandtab: -->
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="docs.txt">View document source</a>.
Generated on: 2009-04-17 14:38 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
