KBUS talk for EuroPython2010
============================

.. [[[
    from rst_terminal import Terminal

    print "Introducing Rosencrantz"
    r = Terminal(1, "Rosencrantz")
    r.do("from kbus import Ksock",
         "rosencrantz = Ksock(0)",
         "print rosencrantz")
.. ]]]

Rosencrantz can send a message.

.. [[[
    r.do("from kbus import Message",
         "ahem = Message('$.Actor.Speak', 'Ahem')",
         "rosencrantz.send_msg(ahem)")
.. ]]]

But no-one is listening.

    (explain about message ids, though)

Introduce the audience, who bind to the message Rosencrantz was using.

.. [[[
    a = Terminal(2, "Audience")
    a.do("from kbus import *",
         "audience = Ksock(0)",
         "audience.bind('$.Actor.Speak')")
.. ]]]

If Rosencrantz sends the message again, the audience can receive it.

    (note the new message id)

.. [[[
    r.do("rosencrantz.send_msg(ahem)")
    a.do("audience.read_next_msg()")
.. ]]]

Or, more prettily

    (note how the message id matches that given to Rosencrantz)

.. [[[
    a.do("print _")
.. ]]]

We can set the audience to listening using 'select'

.. [[[
    a.do("import select",
          "while 1:",
          "   (r,w,x) = select.select([audience], [], [])",
          "   # At this point, r should contain audience",
          "   print audience.read_next_msg()",
          "")
.. ]]]

So now if Rosencrantz talks...

.. [[[
    r.do("rosencrantz.send_msg(Message('$.Actor.Speak', 'Hello there'))",
         "rosencrantz.send_msg(Message('$.Actor.Speak', 'Can you hear me?'))")
.. ]]]

...the audience should be able to hear him:

.. [[[
    a.show()
.. ]]]

Introducing Guildenstern.

.. [[[
    g = Terminal(3, "Guildenstern")
    g.do("from kbus import *",
         "guildenstern = Ksock(0)",
         "print guildenstern")
.. ]]]

Who also starts listening - this time using a wildcard

.. [[[
    g.do("guildenstern.bind('$.Actor.*')")
.. ]]]

In retrospect this makes sense for the audience, too - let's fix that
(and use the KBUS provided way of doing our 'select' loop as well)

.. [[[
    a.do("<CONTROL_C>",
        "audience.bind('$.Actor.*')",
         "while 1:",
         "   print audience.wait_for_msg()",
         "")
.. ]]]

There's nothing for Guildenstern to hear yet, of course.

.. [[[
    g.do("print guildenstern.read_next_msg()")
.. ]]]

Maybe rosencrantz will want to hear his colleague:

.. [[[
    r.do("rosencrantz.bind('$.Actor.*')")
.. ]]]

So let guildenstern speak:

.. [[[
    g.do("guildenstern.send_msg(Message('$.Actor.Speak', 'Pssst!'))",
         "# Remember guildenstern is himself listening to '$.Actor.*'",
         "print guildenstern.read_next_msg()")
.. ]]]

and rosencrantz hears:

.. [[[
    r.do("msg = rosencrantz.read_next_msg()",
         "print msg")
.. ]]]

However, when we look to the audience, we see:

.. [[[
    a.show()
.. ]]]

This is because the audience has bound to the message twice - it is hearing it
once because it asked to receive every ``$.Actor.Speak`` message, and again
because it asked to hear any message matching ``$.Actor.*``.

The solution is simple - ask not to hear the more specific version
(an unbinding must match the binding exactly).

.. [[[
    a.do("<CONTROL-C>",
         "audience.unbind('$.Actor.Speak')",
         "while 1:",
         "   msg = audience.wait_for_msg()",
         "   print msg",
         "")
.. ]]]

Note that messages also say who they are from.

Each Ksock connection has an id associated with it - for instance:

.. [[[
    r.do("rosencrantz.ksock_id()")
.. ]]]

and every message indicates who sent it, so:

.. [[[
    r.do("print msg")
.. ]]]

We've shown that KBUS allows one to "announce" (or, less politely,
"shout") messages, but KBUS also supports asking questions.

So let's make Guildenstern listen to "Speak" messages, and act as a
Replier for "query" messages...

.. [[[
    g.do("guildenstern.unbind('$.Actor.*')",
         "guildenstern.bind('$.Actor.Speak')",
         "guildenstern.bind('$.Actor.Ask.Guildenstern', True)")
.. ]]]

   *(Only one person may be bound as Replier for a particular message
   name at any one time, so that it is unambiguous who is expected to do
   the replying.*

   *Also, if a Sender tries to send a Request, but no-one has bound to that
   message name as a Replier, then an error is raised (contrast that with
   ordinary messages, where if no-one is listening, the message just gets
   ignored).)*

If Rosencrantz then sends a Request of that name:

.. [[[
    r.do("from kbus import Request",
         "req = Request('$.Actor.Ask.Guildenstern', 'Were you speaking to me?')",
         "rosencrantz.send_msg(req)")
.. ]]]

Remember, Rosencrantz still hears himself speaking - so
let's undo that...

.. [[[
    r.do("print rosencrantz.read_next_msg()",
         "rosencrantz.unbind('$.Actor.*')")
.. ]]]

Guildenstern can receive it:

.. [[[
    g.do("msg2 = guildenstern.read_next_msg()",
         "print msg2",
         "msg3 = guildenstern.read_next_msg()",
         "print msg3")
.. ]]]

As we should expect, guildenstern is getting the message twice, once because
he has bound as a listener to '$.Actor.*', and once because he is bound as a
Replier to this specific message.

*(There is, in fact, a way to ask KBUS to only deliver one copy of
a given message, and if guildenstern had used that, he would only have
received the Request that was marked for him to answer. I'm still a little
undecided how often this mechanism should be used, though.)*

Looking at the two messages, the first is the Request specifically to
guildenstern, which he is meant to answer:

.. [[[
    g.do("print msg2.wants_us_to_reply()")
.. ]]]

(and that is what the ``YOU`` in the flags means).

Guildenstern can then reply:

.. [[[
    g.do("reply = reply_to(msg2, 'Yes, yes I was')",
         "print reply",
         "guildenstern.send_msg(reply)",
         "guildenstern.read_next_msg()")
.. ]]]

The ``reply_to`` convenience function crafts a new ``Reply`` message, with the
various message parts set in an appropriate manner. And thus:

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep")
.. ]]]

Note that Rosencrantz didn't need to be bound to this message to receive it -
he will always get a Reply to any Request he sends (KBUS goes to some lengths
to guarantee this, so that even if Guildenstern closes his Ksock, it will
generate a "gone away" message for him).

Of course, the audience was listening.

.. [[[
    a.show()
.. ]]]

-------------------------------------------------------------------------------

Stateful transactions - explanations to be added later.

.. [[[
    r.do("# About to start tossing coins",
         "req = rosencrantz.send_msg(Request('$.Actor.Ask.Guildenstern',",
         "'Will you count heads for me?'))")
.. ]]]

.. [[[
    g.do("req = guildenstern.read_next_msg()",
         "guildenstern.send_msg(reply_to(req, 'Yes, yes I shall'))",
         "guildenstern.bind('$.Actor.CoinToss', True)",
         "heads = 0")
.. ]]]

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep.from_",
         "# Throws a head",
         "from kbus import stateful_request",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

.. [[[
    g.do("while True:",
         "    toss = guildenstern.wait_for_msg()",
         "    if toss.data == 'Head':",
         "       print 'A head - amazing'",
         "       heads += 1",
         "    else:",
         "       print 'Bah, tails'",
         "    guildenstern.send_msg(reply_to(toss, 'Head count is %d'%heads))",
         "")
.. ]]]

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head",
         "sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

The same again:

.. [[[
    g.show()
.. ]]]

Rosencrantz is good at throwing heads:

.. [[[
    r.do("count = rosencrantz.read_next_msg()",
         "print 'So,',count.data",
         "# Throws a head")
.. ]]]

But, aha, Falstaff intervenes, and forces Guildenstern to disconnect:

.. [[[
    g.do("<CONTROL-C>",
         "print 'Ouch'",
         "guildenstern.close()")
.. ]]]

And attempts to hijack the conversation - although, of course, he has no idea
of how many heads have been tossed, so would not actually be of any use:

.. [[[
    f = Terminal(4, "Falstaff")
    f.do("from kbus import *",
         "falstaff = Ksock(0)",
         "falstaff.bind('$.Actor.CoinToss', True)")
.. ]]]

Innocently, Rosencrantz continues:

.. [[[
    r.do("sreq = stateful_request(rep, '$.Actor.CoinToss', 'Head')",
         "rosencrantz.send_msg(sreq)")
.. ]]]

And discovers that, in fact, state has been lost, skulduggery has been done,
and so forth.

::

  $ errno.py 32
  Error 32 (0x20) is EPIPE: Broken pipe

  KBUS:
  On attempting to send 'to' a specific replier, the replier with that id
  is no longer bound to the given message's name.

From the audience's point of view:

.. [[[
    a.show()
.. ]]]

-------------------------------------------------------------------------------

And to end things...

.. [[[
    a.do("<CONTROL_C>",
         "exit()")
.. ]]]

Tidy everyone else up as well (showing that no-one has any messages left):

.. [[[
    r.do("for msg in rosencrantz:",
         "    print msg",
         "",
         "exit()")
    print
    g.do("exit()")
    print
    f.do("for msg in falstaff:",
         "    print msg",
         "",
         "exit()")
.. ]]]

.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
