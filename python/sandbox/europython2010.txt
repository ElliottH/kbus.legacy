KBUS talk for EuroPython2010
============================

.. [[[
    from rst_terminal import Terminal

    print "Introducing Rosencrantz"
    r = Terminal(1, "Rosencrantz")
    r.do("from kbus import Ksock",
         "rosencrantz = Ksock(0)",
         "print rosencrantz")
.. ]]]

Rosencrantz can send a message.

.. [[[
    r.do("from kbus import Message",
         "ahem = Message('$.Actor.Speak', 'Ahem')",
         "rosencrantz.send_msg(ahem)")
.. ]]]

But no-one is listening.

    (explain about message ids, though)

Introduce the audience, who bind to the message Rosencrantz was using.

.. [[[
    a = Terminal(2, "Audience")
    a.do("from kbus import *",
         "audience = Ksock(0)",
         "audience.bind('$.Actor.Speak')")
.. ]]]

If Rosencrantz sends the message again, the audience can receive it.

    (note the new message id)

.. [[[
    r.do("rosencrantz.send_msg(ahem)")
    a.do("audience.read_next_msg()")
.. ]]]

Or, more prettily

    (note how the message id matches that given to Rosencrantz)

.. [[[
    a.do("print _")
.. ]]]

We can set the audience to listening using 'select'

.. [[[
    a.do("import select",
          "while 1:",
          "   (r,w,x) = select.select([audience], [], [])",
          "   # At this point, r should contain audience",
          "   print audience.read_next_msg()",
          "")
.. ]]]

So now if Rosencrantz talks...

.. [[[
    r.do("rosencrantz.send_msg(Message('$.Actor.Speak', 'Hello there'))",
         "rosencrantz.send_msg(Message('$.Actor.Speak', 'Can you hear me?'))")
.. ]]]

...the audience should be able to hear him:

.. [[[
    a.show()
.. ]]]

Introducing Guildenstern.

.. [[[
    g = Terminal(3, "Guildenstern")
    g.do("from kbus import *",
         "guildenstern = Ksock(0)",
         "print guildenstern")
.. ]]]

Who also starts listening - this time using a wildcard

.. [[[
    g.do("guildenstern.bind('$.Actor.*')")
.. ]]]

In retrospect this makes sense for the audience, too - let's fix that
(and use the KBUS provided way of doing our 'select' loop as well)

.. [[[
    a.do("<CONTROL_C>",
        "audience.bind('$.Actor.*')",
         "while 1:",
         "   print audience.wait_for_msg()",
         "")
.. ]]]

There's nothing for Guildenstern to hear yet, of course.

.. [[[
    g.do("print guildenstern.read_next_msg()")
.. ]]]

Maybe rosencrantz will want to hear his colleague:

.. [[[
    r.do("rosencrantz.bind('$.Actor.*')")
.. ]]]

So let guildenstern speak:

.. [[[
    g.do("guildenstern.send_msg(Message('$.Actor.Speak', 'Pssst!'))",
         "# Remember guildenstern is himself listening to '$.Actor.*'",
         "print guildenstern.read_next_msg()")
.. ]]]

and rosencrantz hears:

.. [[[
    r.do("msg = rosencrantz.read_next_msg()",
         "print msg")
.. ]]]

However, when we look to the audience, we see:

.. [[[
    a.show()
.. ]]]

This is because the audience has bound to the message twice - it is hearing it
once because it asked to receive every ``$.Actor.Speak`` message, and again
because it asked to hear any message matching ``$.Actor.*``.

The solution is simple - ask not to hear the more specific version
(an unbinding must match the binding exactly).

.. [[[
    a.do("<CONTROL-C>",
         "audience.unbind('$.Actor.Speak')",
         "while 1:",
         "   msg = audience.wait_for_msg()",
         "   print msg",
         "")
.. ]]]

Note that messages also say who they are from.

Each Ksock connection has an id associated with it - for instance:

.. [[[
    r.do("rosencrantz.ksock_id()")
.. ]]]

and every message indicates who sent it, so:

.. [[[
    r.do("print msg")
.. ]]]

We've shown that KBUS allows one to "announce" (or, less politely,
"shout") messages, but KBUS also supports asking questions.

So let's make Guildenstern listen to "Speak" messages, and act as a
Replier for "query" messages...

.. [[[
    g.do("guildenstern.unbind('$.Actor.*')",
         "guildenstern.bind('$.Actor.Speak')",
         "guildenstern.bind('$.Actor.Guildenstern.Query', True)")
.. ]]]

   *(Only one person may be bound as Replier for a particular message
   name at any one time, so that it is unambiguous who is expected to do
   the replying.*

   *Also, if a Sender tries to send a Request, but no-one has bound to that
   message name as a Replier, then an error is raised (contrast that with
   ordinary messages, where if no-one is listening, the message just gets
   ignored).)*

If Rosencrantz then sends a Request of that name:

.. [[[
    r.do("from kbus import Request",
         "req = Request('$.Actor.Guildenstern.Query', 'Were you speaking to me?')",
         "rosencrantz.send_msg(req)")
.. ]]]

Remember, Rosencrantz still hears himself speaking - so
let's undo that...

.. [[[
    r.do("print rosencrantz.read_next_msg()",
         "rosencrantz.unbind('$.Actor.*')")
.. ]]]

Guildenstern can receive it:

.. [[[
    g.do("msg2 = guildenstern.read_next_msg()",
         "print msg2",
         "msg3 = guildenstern.read_next_msg()",
         "print msg3")
.. ]]]

As we should expect, guildenstern is getting the message twice, once because
he has bound as a listener to '$.Actor.*', and once because he is bound as a
Replier to this specific message.

*(There is, in fact, a way to ask KBUS to only deliver one copy of
a given message, and if guildenstern had used that, he would only have
received the Request that was marked for him to answer. I'm still a little
undecided how often this mechanism should be used, though.)*

Looking at the two messages, the first is the Request specifically to
guildenstern, which he is meant to answer:

.. [[[
    g.do("print msg2.wants_us_to_reply()")
.. ]]]

(and that is what the ``YOU`` in the flags means).

Guildenstern can then reply:

.. [[[
    g.do("reply = reply_to(msg2, 'Yes, yes I was')",
         "print reply",
         "guildenstern.send_msg(reply)",
         "guildenstern.read_next_msg()")
.. ]]]

The ``reply_to`` convenience function crafts a new ``Reply`` message, with the
various message parts set in an appropriate manner. And thus:

.. [[[
    r.do("rep = rosencrantz.read_next_msg()",
         "print rep")
.. ]]]

Note that Rosencrantz didn't need to be bound to this message to receive it -
he will always get a Reply to any Request he sends (KBUS goes to some lengths
to guarantee this, so that even if Guildenstern closes his Ksock, it will
generate a "gone away" message for him).

Of course, the audience was listening.

.. [[[
    a.show()
.. ]]]

.. ============================================================================

And to end things...

.. [[[
    a.do("<CONTROL_C>",
         "exit()")
.. ]]]

Tidy everyone else up as well (note iterating over messages)

.. [[[
    r.do("for msg in rosencrantz:",
         "    print msg",
         "",
         "exit()")
    g.do("for msg in guildenstern:",
         "    print msg",
         "",
         "exit()")
.. ]]]

.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
